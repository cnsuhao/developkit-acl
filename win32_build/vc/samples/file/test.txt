109) 2008.1.16
109.1) acl_vstream.c: 全程跟踪某个套接口的总写入字节数及总读出字节数
109.2) acl_vstream.c: acl_vstream_xxx_ready 类型的函数进行了整理，使逻辑更清晰
109.3) acl_aio_read.c: 增加了针对非阻塞错误号 ACL_EWOULDBLOCK, ACL_EAGAIN 的处理
109.4) acl_aio_read.c: 整理函数，使逻辑更清晰
109.5) acl_aio.c: acl_aio_open() 中强制将套接字转为非阻塞模式
109.6) acl_inet_listen.c: 增加了延迟接收的功能(TCP_DEFER_ACCEPT)，默认的延迟 accept
时间为30秒。

108) 2008.1.15
108.1) acl_dbpool_mysql.c: 一些日志的记录增加了开关设置，即可通过 acl_msg_verbose控制

107) 2008.1.10
107.1) acl_netdb_cache.c: DNS缓存链表的顺序有问题，进行了修复。

106) 2008.1.9
106.1) acl_htable.c: acl_htable_enter, acl_htable_enter_r 中针对添加重复KEY时增加了
日志警告，用户不应添加重复KEY，否则将会导致内存泄漏现象。

105) 2008.1.8
105.1) bugfix: acl_http_header.c->__add_request_item，__add_cookie_item，中对变量对
的存储原来未处理重复变量名的情况，会导致内存泄漏，不过该HTTP库将来将被从基础的ACL库
中去掉，并且该部分函数除了BUG修复外不再做升级，另一个项目：lib_protocol 将提供更加
好的针对各种协议处理的解决方案。

104) 2008.1.7
104.1) 重新整理了 acl_define.h 文件，将与WIN32相关的定义归为一个单独的文件
acl_define_win32.h，这样 acl_define.h 就比较清晰了。
注：由于VC在 extern“C++”方面的限制，会导致编译器出现如下致命错误：
"fatal error C1045: 编译器限制 : 链接规范嵌套太深"
因此，在整理 acl_define_xxx.h 文件时，将 extern "C" 从这些类文件去掉了。
但GCC与BC++却没有这方面的问题，呵呵。不过BC++也有比较弱的地方，在编译库的时候，
必须保证工程的：option->Tlib->Page size 选项为 0x0020，否则如果该值为 0x0010则
BC++也会报一个比较弱的编译错误，如下：
[TLib Error] library too large, please restart with library page size 32
104.2) lib_acl/Makefile, Makefile.mysql: 增加了对MYSQL的编译支持
104.3) dist: 增加了一个专门针对 acl_master 服务器框架的安装包.

103) 2008.1.5
103.1) acl_aio.c: 增加了从异步流中提取异步框架句柄的函数: acl_aio_handle();
103.2) acl_aio_server.c: 增加了acl_aio_server_handle()函数，方便应用在函数自己
的post_init()函数中直接通过此函数提取异步框架句柄。
103.2) acl_aio_server.c: bugfix, 当 acl_master 退出时基于该模板的子进程不退出，
这是与异步流的关闭相关。

102) 2007.12.30
102.1) acl_aio_read.c: 修复了几处错误
102.2) acl_vstream.c: 为 acl_aio_ 异步库提供了更方便的接口
102.3) unix_trigger.c, inet_trigger.c, stream_trigger.c: 可能 events_proc.c 的
定时器与IO事件存在冲突，所以暂时修改了这三个程序，将超时事件的定时器去掉，而是
直接由IO的超时来处理。

101) 2007.12.25
101.1) master_status.c: master_status_event 函数中将acl_vstream_readn修改为read
101.2) acl_aio.c: 在所有的调用timeo_fn()前用增加引用计数的方法来防止流被提前异常关闭
101.3) acl_aio.c: 将流关闭的标记位 closing 统一用 nrefer 来代替
101.4) acl_aio.c: 因为该文件太大了，所以进行了分割，分成几个小模块文件

100) 2007.12.16
100.1) db/acl_dbsql.c, mysql/acl_dbmysql.c: 回调函数的参数my_row 对应于MYSQL_ROW
声明为 const void**, 原来声明为 const void*, 在GCC下编译时报错
100.2) msg/acl_aqueue.c, acl_aqueue_pop_timedwait 的等待时间做一处理，因为UNIX
与WIN32有不同。
100.3) protocol/, 因为声明的HTTP_STATUS_状态宏与VC的冲突，所以修改HTTP_STATUS_
为HTTP_CHAT_。

99) 2007.12.13
99.1) db/acl_dbpool.c: acl_dbpool_destroy函数有一处BUG，在调用子类的销毁函数
后不应再次重复释放同一块内存。

98) 2007.12.7
98.1) acl_define.h: 增加了 acl_unused 宏定义，方便应用避免一些编译时的警告

97) 2007.11.6
97.1) aio/acl_aio.c: 防止遗漏描述符未被关闭现象，所有重要函数回调返回处
都需要判断是不是处于IO完成延迟状态
97.2) aio/acl_aio.c: 增加了许多有用的注释说明，以使该复杂的异步库更加
容易理解，因为该库的设计确实比较复杂
97.3) feature: acl_netdb.c, 添加了一个方便生成 ACL_DNS_DB 的函数
acl_netdb_addip

96) 2007.11.5
96.1) aio/acl_aio.c: 保证非阻塞式写失败错误号的处理正确且兼容各平台
96.2) 整理了所有的 errno, 将其转换为 acl_last_error(), 将 strerror()
转换为 acl_last_strerror()，从而保证平台的移植性

96) 2007.11.3
96.1) net/listen/acl_inet_listen.c: acl_inet_listen():
if (nport <= 0) --> if (nport < 0), 因为acl_msgio_listen传递过来的地址为
"127.0.0.1:0" 的格式，目的是让操作系统自动分配监听端口号

95) 2007.11.2
95.1) 修改了 protocol/ 下的部分函数

94) 2007.11.28--11.30
94.1) 整理 master/ 模块
94.2) 费好大劲才找出 acl_master 无法在 AS3.0 上正常运行的原因: 不能在
acl_define.h 中定义 HAS_DUPLEX_PIPE, 否则会导致
master/framework/master_status.c 中的 acl_master_status_init() 函数在
调用 stdlib/iostuff/acl_duplex_pipe.c 中的 acl_duplex_pipe() 函数时自动
岂用 pipe() 模式.

93) 2007.11.27
93.1) 整理了一下各个模块的位置
93.2) 对LINUX及WINDOWS的兼容性做调整

92) 2007.11.26
92.1) stdlib/acl_msg.c, acl_mylog.c: 记录了日期, 进程号与线程号

91) 2007.11.25
91.1) db: 将数据库模块进行了整理
91.2) thread: 当在WIN32下与MYSQL进行整合时, pthread_xxx 的命名与MYSQL的库
冲突, 所以将 thread/ 下的 pthread_xxx 重新命名为 acl_pthread_xxx

90) 2007.11.23
90.1) portable: 经过长期努力, 终于将WINDOWS版本的ACL与UNIX版本的ACL合并了:)

89) 2007.11.11--11.12
89.1) feature: add the trigger framework to acl_master.
89.2) example: samples/master/trigger/, add one example for trigger

88) 2007.9.11
88.1) example: samples/http_probe, 增加了一个用于探测HTTP服务器状态的例子

87) 2007.9.10
87.1) bugfix: spool/acl_spool.c, 在创建池的时候对参数的判断问题进行修复.
87.2) bugfix: proto/http/http_chat.c, 对HTTP协议的接收处理过程问题进行修复.

86) 2007.8.30
86.1) performance: master/acl_master_listen.c: 监听套接口的监听队列依赖于
main.cf 中的 default_process_limit 值, 当此值比较小时会导致监听套接口的监听
队列也比较小, 从而严重影响了 accept() 的性能, 通过在 acl_master_listen.c 
中限制最小的监听队列来保证 accept() 性能.
87.2) bugfix: master/acl_aio_server.c->aio_server_wakeup() 中的 acl_vstream_fdopen
中的读写超时时间应该为 0, 因为在非阻塞模式下套接口的读写超时时间由事件循环
机制进行控制, 如果此值大于0, 则在 stdlib/acl_vstream.c 中进行真正的IO读时
会有一个多余的 select() 系统调用, 这将会影响非阻塞模式的IO性能.

85) 2007.8.26
85.1) feature: 增加了 /dev/poll for solaris.
85.2) 进一步完善了 engine/ 的事件接口, 隐藏了一些底层的内部接口, 使调用者
更加方便地使用事件接口(engine/events_define.h 中打开 ACL_EVENTS_KERNEL 的
定义, 便可以在 solaris 中使用 /dev/oll 或在 Linux Kernel2.6 以上版本中使用
epoll).

84) 2007.8.23
84.1) portable: rebuilt on solaris.

83) 2007.8.22
83.1) feature: 增加了日志记录的注册函数功能, 可以外挂第三方的日志记录函数库,
stdlib/acl_msg.c, acl_msg.h; 例子参见 samples/master/spool_server/app_log.c.

82) 2007.8.21
82.1) 完善了 acl_aio_server.c 框架模板
82.1) performance: master/acl_spool_server.c
82.3) bugfix: engine/events_thr.c, events_proc.c 中关于定时器的错误修复

81) 2007.8.19
81.1) bugfix: engine/events_proc.c, 为了 master/ 的需要, 修改了 events_proc.c,
及 events_thr.c 中的 events_disable_readwrite() 允许空操作.
81.2) experiment: master/acl_aio_server.c, acl_aio_params.h, 增加了非阻塞库到
master/ 服务框架模型中.

80) 2007.8.14
80.1) 重新调整了 engine/ 下的架构, 对于流的定位与查询不再基于数组定位模式, 以
便于将来移植至 MS Windows 时操作更加方便同时并不会造成性能下降.
80.2) 修改的相关文件: acl_events.c, events_proc.c, events_thr.c, acl_event.h
80.3) 新增的文件: events_fdtable.c, events_fdtable.h
80.4) tagged as milestone

79) 2007.8.11
79.1) portable: 成功将 acl 库移植至 Sun Solaris11 for x86.
79.2) bugfix: acl_vstream.c, event_thr.c, 修改了有关异步读的错误

78) 2007.8.8
78.1) performance: acl_spool.c, acl_vstream.h/acl_vstream.c: 通过在 ACL_VSTREAM
中添加 acl_spool.c 中的内部临时变量(ACL_SPOOL_CTX), 减少了 acl_spool_xxx 的每次
调用过程中的分配与释放内存的次数. (与 acl_aio.c 中的做法类似)
78.2) framework: samples/master/spool_server/, app_main.c/app_main.h, 进一步抽象
了框架接口的调用模式, 以便于用户更加方便地使用.

77) 2007.8.7
77.1) bugfix: engine/event_proc.c

76) 2007.7.17
76.1) bugfix: acl_aio.c->acl_aio_connect() 中未预分配 data_buf 的内存空间
76.2) add on sample: 增加了一个用于高并发测试WEB服务器的例子(samples/http_auto),
该例子可以与WEB服务器一直保持高并发的连接, 如果连接断了会重新建立连接并发送
连接请求.

75) 2007.7.12
75.1) performance: 一定程度上提高了 acl_aio.c 中异步读的性能

74) 2007.7.11
74.1) feature: 增加了针对 Linux2.6 的 epoll 的支持
74.2) performance: 大大提高了异步IO的性能(acl_aio.c, acl_vstream.c)
74.3) example: 针对HTTP服务器(webstar)做性能压力测试, 可以达到450Mbits/s,
12500 request/sec. (./ab -n 1000000 -c 5000 -k http://ip:8080/postfix/)

73) 2007.6.7
73.1) feature: acl_spool.c/acl_spool.h, acl_aio.c/acl_aio.h, 增加了异步
处理函数库的单线程版本, 发现单线程版本的处理能力大约是多线程版本处理能力
的1.5倍左右(原因可能是操作系统的线程调试开销及其它锁机制), 测试程序参见:
sample/aio/. 单线程版本: 41002 次/秒; 多线程版本: 26549 次/秒.

72) 2007.5.29
72.1) bugfix: acl_htable.c/acl_htable.h, 里面在处理多线程加锁处理机制有
问题, 现在已经由新的接口函数替代了

71) 2007.5.27
70.1) acl_htable.c/acl_htable.h: 增加了哈希函数的注册功能及线程安全特性
70.2) 增加了哈希算法函数集于 acl_hash.c, acl_hash.h 中

70) 2007.5.21
70.1) acl_dbpool.c, acl_dbpool.h: 增加了事务自动提交的可配置功能及检测功能

69) 2007.5.20
69.1) acl_spool.c, acl_workq.c: 进一步抽象与完善了任务池的函数接口

68) 2007.5.11
68.1) feature: spool/acl_spool.c, acl_spool.h 增加了任务添加函数接口
68.2) engine/acl_event.c acl_event.h, event_thr.c, event_proc.c: 修改了内部的
流程, 更进一步抽象, 同时使 acl_event_request_timer/acl_event_cancel_timer 具备
多线程工作特性.

67) 2007.5.7
67.1) bugfix: aio/acl_aio.c: acl_aio_read() 中传递的已读数据长度有误.

66) 2007.4.16
66.1) 注释: aio/acl_aio.h 头文件里增加了使用注释

65) 2007.4.14--4.15
65.1) feature: 整理 http/ 协议库...

65) 2007.4.11
65.1) bugfix: aio/acl_aio.c, acl_aio_readn() 的回调函数里有一处漏内存错误.
64.2) feature: 整理 http/ 协议库...

64) 2007.4.10
64.1) feature: 整理 http/ 协议库...

63) 2007.4.9
63.1) feature: aio/acl_aio.c, stdlib/acl_vstream.c, 增加了异步读N个字节的函数.
63.1) feature: 开始整理 proto/http/ 协议库...

62) 2007.4.8
62.1) bugfix: engine/events_thr.c, 去掉了 select() 之后对超时的设定.
62.2) util/aio/: 修改了函数接口的定义方式, 使接口调用方式更加清晰.

61) 2007.4.7
61.1) 检验异步AIO的内存泄漏情况, 发布异步包含异步IO的库(util/aio/).
61.2) 提供异步IO的例子: samples/aio/.

60) 2007.4.6
60.1) 修定了 master/acl_master_ent.c 中的一处BUG: acl_free_master_ent() 函数中
acl_array_destroy() 的调用应在 acl_myfree((char *) serv) 之前.

59) 2007.4.5
59.1) 增加了 aio/ 用于异步IO操作, net/acl_vstream_aync.c 将被丢弃

58) 2007.4.1
58.1) 增加了 master/acl_spool_server.c, 该服务框架基于 spool/acl_spool.c
58.2) 调整了 engine/event_thr.c 中针对 timer 在 event_loop() 的调用关系, 使监听描述符的处理
直接在主循环里进行, 从而缓解了多程模式中 select() 调用中时间值的影响

57) 2007.3.25
57.1) 增了数据库连接池的状态记录日志: util/spool/mysql/acl_dbpool_mysql.c
57.2) 将与 mysql 相关的头文件建立连接实现动态编译: depends/
57.3) bugfix: 修改了几处与编译相关的错误

56) 2007.3.24
56.1) feature: 增加了服务器应用框架及数据库连接池框架 spool/.
56.2) example: 增加了针对 master/listener_server 的例子.
56.3) performance: 修改了 event_thr.c->event_loop() 的事件触发策略, 减少了线程锁的冲突.

55) 2007.2.15
55.1) master/, net/ 经过初步测试已经可以用了:)
55.2) 将 app/master/ 归并到 samples/ 下.

54) 2007.2.14
54.1) feature: stdlib/acl_vstream.c, stdlib/acl_vstream.h, 增加了 acl_vstream_fprintf,
acl_vstream_vfprintf 两个函数, 大大方便了使用者进行数据流的带格式写操作.

53) 2007.2.13
53.1) 对 master/, trigger/, net/ 目录下的一些文件名及函数名重新按 acl/ACL 的命名规范进行了整理
注: 这部分代码仅能编译通过, 还未充分进行测试.

52) 2007.2.3--2.4
52) unit_test: 进行了重大调整, 使其更易用
52.1) 命名规范进行了统一: 函数名前加 aut_, 类型前加 AUT_
52.2) 调整了循环过程的调用方法, 使代码更加清晰.

51) 2007.1.27
51.1) feature: 增加并完善了 listener_server.c/listener_params.h, 该模块做为 master 半驻留进程池模块的补充,
增加了另外一种服务器模型, 该模型仅用于套接口监听, 可以与线程池的服务器模型很好的结合在一起, 即现在已经可以
支持半驻留式的多进程多线程服务器模型; 同时该模型还可用于接收一个请求 fork 一个进程的模式。
51.2) bugfix: event_proc.c/event_thr.c event_XXX_loop 的事件循环中针对 timer 操作的错误.

50)2006.10.20
50.1) app/squid/analog: 增加了一个日志分析程序。

49)2006.8.29
49.1) util/net/acl_vstream_async.c: 修订了一处BUG, 以避免造成内存冲突。
49.2) util/stdlib: acl_mymalloc.c, acl_mymalloc.h, 增加了为了调试内存分配与释放的宏调用(通过在 acl_mymalloc.h
中将宏定义: #define DEBUG_FREE 开关打开即可)。

48) 2006.8.28
48.1) util/stdlib/acl_vstream.c: 增加了acl_vstream_gets_ready()/acl_vstream_gets_nonl_ready(), 使异步通信
操作更加方便, 并且使之与阻塞式方式读缓冲紧密结合在一起, 即：对于一个ACL_VSTREAM 可以同时对其进行同步、异步
读操作。
48.2) util/net: acl_vstream_async.c/acl_vstream_async.h, 因为 acl_vstream.c 从更底层提供了接口，所以该异步
函数集的操作更加简化了，抛弃了原来异步读行的模式，而采用新的异步读行的模式。

47) 2006.8.25
47.1) util/net: acl_vstream_async.c/acl_vstream_async.h, 修改了一处BUG, 内容见 acl_vstream_async.h 中所述.

46 ) 2006.8.11
46.1) util/servtmpl: acl_workq.c/acl_workq.h, 增加了有关连接池功能的调用

45) 2006.7.28
45.1) util/code/, 增加了BASE64编码的两个实现方法

44) 2006.7.27
44.1) util/engine/acl_event.c, 增加了参数入口的判断
44.2) util/master/master_conf.c, 增加服务数量的检查

43) 2006.7.24
43.1) app/weboe/: 避免了内存泄漏的问题, 并且经过了大规模长时间的压力测试及其它的破坏性测试, 说明非阻塞
式框架库基本稳定了.

42) 2006.7.23
42.1) 性能优化与BUG修复, event_thr.c->event_thr_loop() 中锁的控制, 改变了 dipatch_fn() 的函数接口参数,
从而避免了一些复杂的容易出错的释放操作, 并且减少了加锁次数.
42.2) event_thr.c->event_thr_loop() 中又减少了某一种锁的冲突.

41) 2006.7.11
41.1) 调整了参数，使非阻塞服务器的性能得到大幅提高

40) 2006.7.5
40.1) Bugfix: acl_vstream_async.c->__handle_line_data() 中依然有一处错误, 现已经进行了修正

39) 2006.7.3 night
39.1) Feature: 通过修改 __handle_line_data(), acl_vstream_async_buf_new() 两个函数进一步提高了执行效率,
减少了数据移动拷贝现象.
39.2) Feature: 通过增加 acl_vstream_async_buf_new() 的参数列表及修改 __handle_line_data() 函数，增加了
针对一行数据的长度的最大值限制, 从而进一步避免缓存区溢出问题.

38) 2006.7.2
38.1) Bugfix: 修改了异步通信库的一个错误, 发生于异步读一行的函数处理中: util/net/acl_vstream_async.c 中
的  __handle_line_data() 函数.
38.2) 将 util/stdlib/acl_vstream.c, .h 中的 acl_vstream_vstring_readn 改名为:acl_vstream_vstring_append_readn

37) 2006.6.23
Feature: 完善了异步通信的接口: util/stdlib/acl_vstream.c, util/engine/acl_events.c,
util/net/acl_vstream_async.c. 在 ACL_VSTREMA 结构类型中增加了注销函数数组: close_handle_lnk, 以保证
当数据流被关闭前先倒序调用各个已经在该数组中注册的析构函数; 在 ACL_EVENT 结构中增加了线程锁成员
变量: lock_mutex, 对于处于线程事件的循环中该锁将起作用, 对于进程类型的事件循环该锁不起作用, 因为增加
了该锁, 从而使 acl_vstream_async.c 中不在存在线程锁的调用, 而是将锁的调用移至 acl_events.c中.

36) 2006.6.15
Bugfix: 修订了有关域名解析部分线程不安全的函数: util/net/myaddinfo.c
Bugfix: util/net/acl_vstream_net.c 中的acl_vstream_connect() 函数中在调用 acl_vstream_fdopen()
时参数顺序有错误。

35) 2006.6.13
增加了探测程序: app/squid/probe

34) 2006.6.8
完善了线程库部分.
Feature: 增加线程读写锁部分, util/ipc/acl_thread_rwlock.c, acl_thread_rwlock.h
Feature: 将以前的内存DB放置该库中

33) 2006.6.7
Bugfix: 修订了有些函数在调用 acl_vstream_fdopen() 时的各个参数顺序的BUG!!!, 费了好大劲才找出此错误:(
Test: 增加了两个测试线程池库的实例(app/thread_server/server2, server3)

32) 2006.6.6
写了一个用来测试线程库的实例(app/thread_server/server1)

31) 2006.6.4
为了避免函数的名字空间冲突，修改了大量的函数，将所有函数名及类型名前均增加 ACL_ 前缀，同时将
源程序名前增加 acl_ 前缀。至此，本函数库的工作被定义为 acl_project 工程. ---zsx
注： acl 是 advanced c library 的英文简写.
     建议使用者尽是使用 ACL_ 开头的函数及类型，其它的函数及类型并不保证将来的兼容性。

30) 2006.5.30
Feature(debug status): 1) 增加了另一个线程池的库: servertmpl/workq.c, workq.h, worker.c, worker.h
Name: 确定以后将本函数库命名为 : ACL(高级的 C 库)

29) 2006.4.30
Portable: 查询了所有的Makefile，将其中的所有的编译选项 -gdwarf 都换成 -g，以兼容新的
编译器要求，折腾了俺一上午时间:(

28) 2005.12.14
Feature: 1) 提供了另外一个 vstream_fseek 函数, 该新函数的效率更高, 且把第一版本的 vstream_fseek
重新命名为 vstream_fseek2. 另外加强了测试代码.

27) 2005.12.13
Feature: 1) 增加了 vstream_fseek 函数

26) 2005.10.24
Feature: 1) 增加了 util/stdlib/filedir/make_dirs.c 文件, 从而可以创建一级或多级目录

25) 2005.10.8
Bugfix: 1) 在 app/master/multi_proxy/multi_proxy.c 中, 在打开文件数据流时没有将文件指针移至文件
的结尾, 故增加了 O_APPEND, 使每次打开文件数据流时都使文件指针指向文件的最后.
Feature: 1) 在 app/master/master.c 中增加了写 master 进程的 pid 的功能, 这样可以使诸如 stop.sh
之类的脚本来停止主控进程.

24) 2005.9.27
Feature: 1) 针对 multi_server.c 增加了记录信息的功能

23) 2005.9.26
Bugfix: 1) 修复了 __proc(thread)__event_loop() 中的一处错误, 即当 nowait != 0 时, 应该设置指针 tvp
的值而不应设置其为空指针, 否则会导致后面的 select() 调用永远等待; 2) multi_server.c 中有一处错误,
在一个 switch() 条件中缺少一个 break.
Feature: 1) 修改了 multi_proxy.c 文件, 使其变得更加通用:)

22) 2005.9.25
Feature: 1) 针对 multi_server.c, 增加了读超时的处理功能, 这对于处理非阻塞模式的读超时非常　有价值.

21) 2005.9.22
Bugfix: 1) 通过边界测试(即设置缓冲区分别为2, 4, 4096, 8192)时, 发现代理服务器(multi_proxy)会有异
常退出的问题, 经过仔细检查, 发现是服务框架事件处理函数(event.c)有问题, 即当外部函数通过调用函数
event_disable_readwrite()来关闭永久可读写描述集时, 因为 ..._event_loop() 中所用的临时描述集未被清
除, 这样就产生了不同步清理的问题, 从而造成调用 select() 时报严重的错误: 有非法的描述符存在于描述
符集合中, 解决方法是在 EVENT 的结构中增加临时描述集, 用来代替 ..._event_loop() 中的局部描述集,
所修改的文件主要有: event.c, event.h

20) 2005.9.19
Portable: 20.1) can run on HP-UX

19) 2005.9.11
Workaround: 19.1) 增加了使用 multi_server.c 框架的代理服务器, 19.2) 修补了 multi_server.c 中的几
处 bug

18) 2005.9.10
Workaround: 18.1) 归整了一些变量的命名格式, 并去掉了一一些无用的变量

17) 2005.9.9
Bugfix: 17.1) 修改了 events.c 中的一处 bug
Feature: 17.1) 增加了一个测试程序: single_proxy/

16) 2005.9.6
Workaround: 16.1) 移植到了 SUN 平台上, 并修改了几处

15) 2005.9.5
Feature: 15.1) 增加了 VSTREAM_STDIN, VSTREAM_STDOUT, VSTREAM_STDERR 三个标准的数据流

14) 2005.9.4
Workaround: 14.1) 使 multi_server() 服务框架可以正常使用了
Bugfix: 14.1) 修复了 servtmpl/event.c 中的一个处 bug: 当有可用的描述字中流中有数据时, 则需要将
select() 所需要的时间等待时间设置为 0.

13) 2005.8.28
Workaround: 13.1) 调整了一些程序的书写格式, 同时还明白了 throttle_delay 的真正含义: 即当子进程非
法退出后, 父进程将停止相应的服务的时间间隔为 throttle_delay.

12) 2005.8.27
Workaround: 12.1) 基本调度成功　了 single_server 的服务框架模式:)

11) 2005.8.24
Workaround: 11.1) 修改了 events.c/.h, 使之支持进程池的模式, 在进程池模式下不需要检查描述符是否
处于忙状态; 在线程池模式下需要检查描述符是否处于忙状态; 11.2) 继续完善 util/master/ 下的文件,
基本实现了半驻留服务模式的运行.

10) 2005.8.21
Bugfix: 10.1) 修复了 xinetd_cfg.c 中的一处错误
Feature: 10.1) 针对 xinetd_cfg.c/.h 增加了 xinetd_cfg_index(...) 函数
Workaround: 10.1) 继续完善了 master/ 库函数

9) 2005.8.15
Workaround: 9.1) 终于使 master 可以运行了:) util/master/: master_vars.c, master_params.c,
master_params.h, master_conf.c, master_service.c, master.h, master_ent.c, master_avail.c,
master_sig.c, master_spawn.c, master_status.c,  master_wakeup.c

8) 2005.8.14
Workaround: 8.1) 将 master 编译成功:), app/master/: master.c

7) 2005.8.9
Bugfic: 7.1) 修补了一处可能会造成内存泄漏的错误, master_ent.c
Workaround: 7.1) 整理了 master/ 目录下的文件, 仅剩余 mail_flow.c 等几个文件未整理.

6) 2005.8.8
Workaround: 6.1) 修改了目录结构, 在 stdlib/ 目录下建立了 proc_specific/ 目录, 该目录今后将存放
仅在进程编程时才用的库函数, 这些库函数是线程不安全的; 6.2) 将测试 watchdog 库的程序移动到专门的
测试程序目录下(test_util/watchdog/), 还有 test_util/inet/; 6.3) 修改了两个头文件(cgi-rep.h 及
cgi-util.h), 在其中增加了针对 C++ 编译引用的支持.; 6.4) 继续完善 master 函数库 (master/)

5) 2005.7.29
Feature: 5.1) 增加了针对异读、异步连接、异步读行的读超时功能(这是微软的异步SOCKET里所不具备的).
event.h, event.c, vstream_async.c, vstream_async.h, readline_async/, tcp_proxy/.

4) 2005.7.25
Feature: 4.1) 在 vstream.c 中, 增加了 vstream_vstring_readn(), 从而可以利用 vstring 的特性来拷贝
数据; 4.2) 在 vstream_async.c 中增加了 vstream_async_gets(), 从而可以将获得一行作为事件通知条件,
当缓冲区内有一行数据时才会通知应用程序, 即实现了读取行非阻塞的模式.
Test: 4.1) 在 app/ 目录下增加了工程: readline_async/, 用于测试异步读取整行数据的库函数.

3) 2005.7.18
Workaround: 3.1) 修改了 vstream_net.c/h 文件, 将 vstream_listen2 修改为 vstream_listen_ex, 并增加
了一个 block_mode 的参数, 从而使数据流完全遵守非阻塞模式; 3.2) vstream_async.c, 在 vstream_listen_ex
中增加了 NON_BLOCKING 参数.

2) 2005.7.10
Workaround: 2.1) 重新改写了各个 Makefile 文件, 可以自动从环境变量中取得用 gcc 编译还是用 g++ 编译;
2.2) 修改各个 .c 及 .h 文件, 消除了在用 g++ 编译时的错误与警告, 以使本函数库可以用方便地应用在一
些 C++ 的程序中.

1) 2005.7.9
Bugfix: 修订了 servtmpl/events.c 中的两处 BUG, 1.1) event_enable_write() 及 event_enable_read()
中增加了防止上一次操作中未将状态设置为空闲的隐患; 1.2) event_loop() 以前在最初设置描述符集合时没
有将处于忙状态的描述符清除掉.

